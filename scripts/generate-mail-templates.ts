import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import * as path from "node:path";
import mjml2html from "mjml";

const repoRoot = process.cwd();
const templatesDir = path.join(repoRoot, "server", "mail", "templates");
const generatedDir = path.join(repoRoot, "server", "mail", "generated");

function sanitizeTemplateLiteral(input: string) {
  // Escape backticks and ${ to avoid breaking the generated TS.
  return input.replace(/`/g, "\\`").replace(/\\$\{/g, "\\${");
}

function pascal(input: string) {
  // Convert e.g. `admin-invite` -> `AdminInvite`
  const parts = input
    .split(/[^a-zA-Z0-9]+/g)
    .filter(Boolean)
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1));

  const out = parts.join("");

  // TypeScript identifiers cannot start with a digit.
  return out.length === 0 ? "Template" : out.replace(/^[0-9]/, (d) => `_${d}`);
}

function stripDtsToTemplateDataSource(dtsSource: string, typeName: string) {
  // Goal: take a `.d.ts` file that exports `TemplateData` and inline it into the
  // generated module as `export type ${typeName} = ...`.
  // Keep it intentionally simple: remove imports/exports we don't want and rewrite the TemplateData name.

  let s = dtsSource;

  // Remove `export` keyword (re-exported ourselves later)
  s = s.replace(/\bexport\s+/g, "");

  // Convert `type TemplateData` to our generated name
  s = s.replace(/\btype\s+TemplateData\b/g, `type ${typeName}`);

  s = s.trim();
  return s.length ? `${s}\n` : "";
}

async function generateTemplate(templateName: string) {
  const mjmlPath = path.join(templatesDir, `${templateName}.mjml`);
  const mjmlSource = await readFile(mjmlPath, "utf8");

  const {html, errors} = mjml2html(mjmlSource, {
    validationLevel: "strict",
    filePath: mjmlPath,
    minify: false,
  });

  if (errors?.length) {
    const pretty = errors
      .map((e) => String(e.formattedMessage ?? e.message ?? e))
      .join("\n");
    throw new Error(`MJML compilation failed for ${templateName}.mjml\n${pretty}`);
  }

  const typeName = `${pascal(templateName)}TemplateData`;

  // Inline typing from adjacent .d.ts if it exists. If not, fallback.
  const dtsPath = path.join(templatesDir, `${templateName}.d.ts`);
  let typeBlock = `export type ${typeName} = Record<string, unknown>;\n`;

  if (existsSync(dtsPath)) {
    const dtsSource = await readFile(dtsPath, "utf8");
    const inlined = stripDtsToTemplateDataSource(dtsSource, typeName);
    if (inlined.includes(typeName)) {
      typeBlock = `export ${inlined.replace(new RegExp(`\\btype\\s+${typeName}\\b`), `type ${typeName}`)}`;
    } else {
      throw new Error(
        `[mail] ${path.relative(repoRoot, dtsPath)} must export a type or interface named TemplateData.`,
      );
    }
  }

  const ts = `/* eslint-disable */
// This file is auto-generated by scripts/generate-mail-templates.ts
// Do not edit by hand. Edit ../templates/${templateName}.mjml instead.

import Handlebars from "handlebars";

${typeBlock}

const templateSource = \`${sanitizeTemplateLiteral(html)}\`;

let compiled: Handlebars.TemplateDelegate | undefined;

export default function render(data?: ${typeName}): string {
  if (!compiled) {
    compiled = Handlebars.compile(templateSource, { noEscape: true });
  }
  return compiled(data);
}
`;

  await writeFile(path.join(generatedDir, `${templateName}.ts`), ts, "utf8");
}

async function main() {
  const files = await readdir(templatesDir);
  const templateNames = files
    .filter((f) => f.endsWith(".mjml"))
    .map((f) => f.replace(/\.mjml$/, ""));

  if (templateNames.length === 0) {
    console.warn(`[mail] No .mjml templates found in ${templatesDir}`);
    return;
  }

  await mkdir(generatedDir, {recursive: true});

  for (const name of templateNames) {
    await generateTemplate(name);
  }

  // Barrel file for easier imports.
  const exports = templateNames
    .map((name) => `export { default as ${pascal(name)} } from "./${name}";`)
    .join("\n");

  const exportedTypes = templateNames
    .map((name) => `export type { ${pascal(name)}TemplateData } from "./${name}";`)
    .join("\n");

  await writeFile(
    path.join(generatedDir, "index.ts"),
    `/* eslint-disable */\n// Auto-generated by scripts/generate-mail-templates.ts\n${exports}\n\n${exportedTypes}\n`,
    "utf8",
  );

  console.log(`[mail] Generated ${templateNames.length} template(s) into server/mail/generated`);
}

main().catch((err) => {
  console.error(err);
  return 1;
});
